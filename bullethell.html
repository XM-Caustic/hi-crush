<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Bullet Hell</title>
  <style>
    :root{--bg:#0b0f1a;--fg:#e6f1ff;--accent:#ff4d6d}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{background:linear-gradient(180deg,#061124 0%, #071428 60%);color:var(--fg);display:flex;align-items:center;justify-content:center}
    .wrap{width:100%;max-width:900px;padding:18px;box-sizing:border-box}
    header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
    h1{font-size:18px;margin:0}
    .hud{margin-left:auto;display:flex;gap:8px;align-items:center}
    button{background:#111827;border:1px solid rgba(255,255,255,0.06);color:var(--fg);padding:6px 10px;border-radius:8px;cursor:pointer}
    canvas{display:block;width:100%;height:600px;background:radial-gradient(circle at 10% 10%, rgba(255,255,255,0.02), transparent 10%), var(--bg);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.7)}
    .controls{font-size:13px;margin-top:8px;opacity:0.9}
    .footer{margin-top:8px;color:rgba(230,241,255,0.6);font-size:13px}
    .stat{font-weight:700;color:var(--accent);margin-left:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Mini Bullet Hell</h1>
      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn">Restart</button>
      </div>
    </header>

    <canvas id="game"></canvas>
    <div class="controls">Move: <strong>arrow keys / WASD</strong> or <strong>mouse</strong>. Shoot: <strong>space</strong> or <strong>left click</strong>. Hold to rapid-fire. Survive as long as you can!</div>
    <div class="footer">Tip: survive for higher difficulty — enemies fire more bullets over time. <span class="stat">Have fun!</span></div>
  </div>

<script>
// Single-file bullet hell — simple but extensible
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 900, H = 600;
  function resize(){
    const ratio = Math.min(1, window.innerWidth/1000);
    W = Math.max(400, Math.floor(900*ratio));
    H = Math.max(280, Math.floor(600*ratio));
    canvas.width = W; canvas.height = H;
  }
  window.addEventListener('resize', resize);
  resize();

  // Game state
  let score = 0, lives = 3, paused = false, running = true;
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  pauseBtn.onclick = () => { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; };
  restartBtn.onclick = reset;

  // Player
  const player = {
    x: W/2, y: H - 70, r: 10, speed: 350,
    cooldown: 0
  };

  // Input
  const keys = {};
  let mouse = {x:0,y:0,down:false};
  window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()] = true; if(e.key===' '){e.preventDefault();}});
  window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()] = false;});
  canvas.addEventListener('mousemove', e=>{const rect=canvas.getBoundingClientRect();mouse.x=(e.clientX-rect.left)*(canvas.width/rect.width);mouse.y=(e.clientY-rect.top)*(canvas.height/rect.height);});
  canvas.addEventListener('mousedown', e=>{mouse.down=true});
  window.addEventListener('mouseup', e=>{mouse.down=false});

  // Entities
  const bullets = []; // player bullets
  const enemyBullets = [];
  const enemies = [];

  function spawnEnemyPattern(t){
    // pattern depends on time t
    const wave = Math.floor(t/8);
    const count = 5 + Math.min(6, Math.floor(wave/2));
    const yBase = -30;
    for(let i=0;i<count;i++){
      const phase = (i/count)*Math.PI*2;
      enemies.push({
        x: 80 + (W-160)*(i/(count-1||1)),
        y: yBase - i*20,
        r: 12,
        hp: 1 + Math.floor(wave/3),
        pattern: (dt)=>{
          // sinusoidal entry then hover
          const speed = 40 + Math.min(60,wave*6);
          this_ = dt; // placeholder
        },
        timer: 0,
        type: 'orb'
      });
    }
  }

  // Spawn boss-like shooter occasionally
  function spawnShooter(){
    enemies.push({x:W/2,y:-60,r:22,hp:8,type:'shooter',timer:0,angle:0});
  }

  let spawnTimer = 0; let timeAlive = 0; let nextShooterAt = 18;

  function update(dt){
    if(paused || !running) return;
    timeAlive += dt;
    spawnTimer += dt;
    // spawn waves
    if(spawnTimer > 3.5){ spawnEnemyPattern(timeAlive); spawnTimer = 0; }
    if(timeAlive > nextShooterAt){ spawnShooter(); nextShooterAt += 20; }

    // Player movement
    let dx = 0, dy = 0;
    if(keys['arrowleft']||keys['a']) dx -= 1;
    if(keys['arrowright']||keys['d']) dx += 1;
    if(keys['arrowup']||keys['w']) dy -= 1;
    if(keys['arrowdown']||keys['s']) dy += 1;
    const usingMouse = (mouse.x>0||mouse.y>0) && (mouse.x<canvas.width && mouse.y<canvas.height);
    if(usingMouse && (mouse.down || keys['shift'])){
      // allow mouse tracking movement
      const mx = mouse.x, my = mouse.y;
      const ease = 14;
      player.x += (mx - player.x)/ease;
      player.y += (my - player.y)/ease;
    } else {
      const mag = Math.hypot(dx,dy) || 1;
      player.x += (dx/mag)*player.speed*dt;
      player.y += (dy/mag)*player.speed*dt;
    }
    // clamp
    player.x = Math.max(12, Math.min(W-12, player.x));
    player.y = Math.max(12, Math.min(H-12, player.y));

    // Shooting
    player.cooldown -= dt;
    const wantShoot = keys[' '] || mouse.down;
    if(wantShoot && player.cooldown <= 0){
      player.cooldown = 0.12; // fire rate
      bullets.push({x:player.x,y:player.y-14,vx:0,vy:-520, r:4});
      // two side bullets occasionally
      bullets.push({x:player.x-8,y:player.y-10,vx:-90,vy:-420,r:3});
      bullets.push({x:player.x+8,y:player.y-10,vx:90,vy:-420,r:3});
    }

    // Update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt;
      if(b.y < -20 || b.x < -40 || b.x > W+40) bullets.splice(i,1);
    }
    for(let i=enemyBullets.length-1;i>=0;i--){
      const b = enemyBullets[i]; b.x += b.vx*dt; b.y += b.vy*dt; b.timer+=dt;
      if(b.y > H+40 || b.x < -40 || b.x > W+40) enemyBullets.splice(i,1);
    }

    // Update enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i]; e.timer += dt;
      if(e.type==='orb'){
        // move down then hover with sine
        e.y += (30 + Math.sin(timeAlive + i)*18)*dt;
        e.x += Math.sin(e.timer*1.2 + i)*18*dt;
        // shoot bullets occasionally
        if(Math.random() < 0.008 + Math.min(0.02, timeAlive/200)){
          // shoot towards player with spread
          const ang = Math.atan2(player.y - e.y, player.x - e.x);
          for(let s=-2;s<=2;s++){
            const a = ang + s*0.12;
            enemyBullets.push({x:e.x,y:e.y,vx: Math.cos(a)*140, vy: Math.sin(a)*140, r:3});
          }
        }
      } else if(e.type==='shooter'){
        // center then rotate and fire bullet ring
        if(e.y < 120) e.y += 40*dt; else {
          e.angle += dt*1.4;
          if(e.timer % 0.6 < dt){
            const count = 12 + Math.floor(timeAlive/25);
            for(let k=0;k<count;k++){
              const a = (k/count)*Math.PI*2 + e.angle;
              enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*(120+timeAlive/6), vy:Math.sin(a)*(120+timeAlive/6), r:4});
            }
          }
          // aim bursts at player
          if(Math.random() < 0.025 + Math.min(0.06, timeAlive/300)){
            const ang = Math.atan2(player.y-e.y, player.x-e.x);
            for(let s=-1;s<=1;s++){
              const a = ang + s*0.08;
              enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*220, vy:Math.sin(a)*220, r:3});
            }
          }
        }
      }

      // collision with player bullets
      for(let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        const dx = b.x - e.x, dy = b.y - e.y;
        if(dx*dx + dy*dy < (b.r + e.r)*(b.r + e.r)){
          bullets.splice(j,1);
          e.hp -= 1;
          if(e.hp <= 0){ score += (e.type==='shooter')? 120 : 20; enemies.splice(i,1); break; }
        }
      }

      // collision with player
      const dxp = player.x - e.x, dyp = player.y - e.y;
      if(dxp*dxp + dyp*dyp < (player.r + e.r)*(player.r + e.r)){
        // hit!
        damagePlayer();
        enemies.splice(i,1);
      }

      // remove if offscreen far below
      if(e.y > H + 120) enemies.splice(i,1);
    }

    // enemy bullets hitting player
    for(let i=enemyBullets.length-1;i>=0;i--){
      const b = enemyBullets[i];
      const dx = b.x - player.x, dy = b.y - player.y;
      if(dx*dx + dy*dy < (b.r + player.r)*(b.r + player.r)){
        enemyBullets.splice(i,1);
        damagePlayer();
      }
    }

    scoreEl.textContent = Math.floor(score);
    livesEl.textContent = lives;

    // gradually increase score
    score += dt*5;
  }

  function damagePlayer(){
    // temporary invulnerability handled by simple reset
    lives -= 1;
    if(lives <= 0){
      running = false; paused = true; pauseBtn.textContent = 'Paused';
      setTimeout(()=>{ alert('GAME OVER — Score: ' + Math.floor(score)); }, 50);
    } else {
      // respawn player center
      player.x = W/2; player.y = H - 80;
      bullets.length = 0; enemyBullets.length = 0;
    }
  }

  // Render
  function draw(){
    // background
    ctx.clearRect(0,0,W,H);
    // starfield
    for(let i=0;i<60;i++){
      const sx = (i*97)%W, sy = (i*53 + (timeAlive*10*(1+i%3)))%H;
      ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(sx,sy,1,1);
    }

    // player
    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,10); ctx.lineTo(0,6); ctx.lineTo(-8,10); ctx.closePath();
    ctx.fillStyle = '#e6f1ff'; ctx.fill();
    ctx.restore();

    // bullets
    bullets.forEach(b=>{ ctx.beginPath(); ctx.fillStyle='#9be3ff'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });
    enemyBullets.forEach(b=>{ ctx.beginPath(); ctx.fillStyle='#ffb2c1'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });

    // enemies
    enemies.forEach(e=>{
      ctx.save(); ctx.translate(e.x,e.y);
      if(e.type==='orb'){
        ctx.beginPath(); ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fillStyle='#ffd36b'; ctx.fill();
        ctx.beginPath(); ctx.arc(0,0,e.r-4,0,Math.PI*2); ctx.fillStyle='rgba(3,8,23,0.3)'; ctx.fill();
      } else if(e.type==='shooter'){
        ctx.beginPath(); ctx.moveTo(-e.r,0); ctx.lineTo(0,-e.r); ctx.lineTo(e.r,0); ctx.lineTo(0,e.r); ctx.closePath(); ctx.fillStyle='#ff9ab3'; ctx.fill();
        ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fill();
      }
      ctx.restore();
    });

    // UI time/difficulty
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(8,8,150,28);
    ctx.fillStyle='#dfefff'; ctx.font='13px system-ui,Arial'; ctx.fillText('Time: ' + Math.floor(timeAlive) + 's', 14, 26);
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05,(now-last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // helpers
  function reset(){
    score = 0; lives = 3; paused = false; running = true; timeAlive = 0; spawnTimer = 0; enemies.length = 0; bullets.length = 0; enemyBullets.length = 0; nextShooterAt = 18; player.x = W/2; player.y = H-70; pauseBtn.textContent='Pause';
  }

  // friendly keyboard shortcuts
  window.addEventListener('keydown', e=>{
    if(e.key === 'p') { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
    if(e.key === 'r') reset();
  });

  // auto-start message on click to enable some browsers' audio in future (placeholder)
  canvas.addEventListener('click', ()=>{ if(!running){ reset(); } });

})();
</script>
</body>
</html>
